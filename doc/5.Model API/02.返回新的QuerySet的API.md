# 返回新的queryset的API
## 1.all()  filter()  order_by()  exclude()  reverse() distinct()

### 1.1 all()查询所有数据

### 1.2 filter()返回满足条件的对象

### 1.3 order_by()根据某个字段进行排序

### 1.4 exclude():除了xx元素以外
```python
        s1 = Student.objects.all().exclude(nickname="A同学")
        for s in s1:
            # print(s.nickname, s.age)
            pass
```
### 1.5 reverse():反向排序
```python
        s2 = Student.objects.all().exclude(nickname="A同学").reverse()
        for s in s2:
            # print(s.nickname, s.age)
            pass
```

**一定要在模型的Meta中用`ordering`指定排序的字段**
**多个ordering的时候取第一个**
**默认按照关键字的顺序输出**
**更改此项不需要重新生成数据表**
```python
    class Meta:
        ...
        ordering = ["age"]  # 更改此项不需要重新生成数据表
```

### 1.6 distinct():去重

## 2.extra()   defer()   only()

### 2.1 extra():给字段取别名
> extra(): extra(select={"[要取的别名]": "[原来字段名]"})
```python
        s3 = Student.objects.all().extra(select={"name": "nickname"})
        for s in s3:
            # print(s.name, s.age)
            pass

```

### 2.2 defer():排除一些字段

### 2.3 only():选择一些字段
```python
  print(
            str(Student.objects.all().only("nickname", "age").query)
        )  # SELECT `courses_student`.`nickname`, `courses_student`.`age` FROM `courses_student` ORDER BY `courses_student`.`age` ASC
```


## 3.values() values_list()  获取字典或者是元组形式的queryset

### 3.1 values():字典
> 输出的是dict类型的
```python
        print(TeacherAssistant.objects.values("nickname", "hobby"))
        # <QuerySet [{'nickname': '助教1', 'hobby': '看老友记'}, {'nickname': '助教2', 'hobby': '看生活大爆炸'}, {'nickname': '助教3', 'hobby': '看小鲤鱼历险记'}]>
```

### 3.2 values_list():元组
> 输出的是元组类型的数据
```python
        print(TeacherAssistant.objects.values_list("nickname", "hobby"))
        # <QuerySet [('助教1', '看老友记'), ('助教2', '看生活大爆炸'), ('助教3', '看小鲤鱼历险记')]>
```

> flat:将单个字段的数据直接放到列表里面  只限于获取单个数据的信息
```python
        print(TeacherAssistant.objects.values_list("nickname", flat=True))
        # <QuerySet ['助教2', '助教3', '助教1']>
```

## 4. dates  datetimes 根据时间和日期获取查询集

### 4.1 dates:根据时间获取查询集
> dates('[查询日期的字段]', '查询是 year month day', order='是降序DESC 升序ASC(默认) ')

```python
        print(Course.objects.dates("created_at", "month", order="DESC"))
        # <QuerySet [datetime.date(2023, 8, 1), datetime.date(2023, 7, 1), datetime.date(2023, 6, 1)]>
        # datetimes('[查询时间的字段]', 'month', order='DESC')
```

### 4.2 datetimes:根据日期获取查询集
> datetimes('[查询时间的字段]', 'month', order='DESC')

```python
print(Course.objects.datetimes("created_at", "month", order="DESC"))
```

## 5. union()   intersection()   difference()  集合的运算
```python
        s1 = Course.objects.filter(price__gte=240)  # 大于等于240
        s2 = Course.objects.filter(price__lte=260)  # 小于等于260
```

### 5.1 union():并集
```python
print(s1.union(s2))  # 并集

#或者
print(s1 | s2)  # 并集

# print(s1 + s2)  # 并集
# unsupported operand type(s) for - / + : 'QuerySet' and 'QuerySet' 不支
```

### 5.2 intersection():交集
```python
print(s1.intersection(s2))  # 交集

"""
低版本的MySQL 不支持 intersection 和  difference，目前版本支持
"""
# 或者
print(s1 & s2)  # 交集

```

### 5.3 difference():差集
```python
print(s1.difference(s2))  # 差集

"""
低版本的MySQL 不支持 intersection 和  difference，目前版本支持
"""

# 或者
# print(s1 - s2)  # 差集
# unsupported operand type(s) for - / + : 'QuerySet' and 'QuerySet' 不支持
```

## 6.select_related prefetch_related 优化查询api 

### 6.1 select_related() 一对一 多对一

### 6.2 prefetch_related() 一对多 多对多



