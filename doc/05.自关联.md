# 自关联
前面都是一个数据表关联另一个数据表，现在我们让一个模型表关联他自己。就是**一张数据表中一条记录关联到另一条记录**。

比如需要在一张表里存储省市县，那我们需要设置三个不同的模型类，分别来存储省、市、县地址信息，通过一对多的外键进行关联，这样不科学。
合理的方式通过自关联来实现。

# 示例
```python
class AddressInfo(models.Model):
    """
    存储省市县地址信息
    """

    address = models.CharField(max_length=200, null=True, blank=True, verbose_name="地址")
    # 自关联数据表需要设置一个自关联字段
    pid = models.ForeignKey("self", null=True, blank=True,verbose_name="自关联")
    # pid = models.ForeignKey("AddressInfo", null=True, verbose_name="自关联")  # 两种写法

    def __str__(self):  # python 2 中写法是 __unicode__ (self)_
        return self.address  # 这里返回地址信息，通常可以返回上面写好的字段

```

进行 `makemigrations`报错
## 报错信息
```sh
TypeError: ForeignKey.__init__() missing 1 required positional argument: 'on_delete'
```
## 分析原因
Django 升级到 v2.0 +, `models.ForeignKey()`函数和`models.OneToOneField()`中的`on_delete`参数不再是默认`CASCADE`,而是必须参数 
[官方文档](https://docs.djangoproject.com/en/4.2//ref/models/fields/#django.db.models.ForeignKey.on_delete)

## 解决方式
加上 `on_delete=models.CASCADE`
```diff
-    pid = models.ForeignKey("self", null=True, blank=True,verbose_name="自关联")
+    pid = models.ForeignKey(
+        "self", null=True, blank=True, verbose_name="自关联", on_delete=models.CASCADE
+    )
```
